# 计算机网络

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）

> 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

简洁版

- 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图像等）；
- 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
- 载入解析到的资源文件，渲染页面，完成。

![img](http://7xkpdt.com1.z0.glb.clouddn.com/7af8074fc21748eca9e93c261298860f.png)

详细版

1. 浏览器会开启一个新的线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
2. 通过 DNS 解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
3. 进行 HTTP 协议会话，客户端发送报头(请求报头);
4. 进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
5. 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
6. 处理结束回馈报头，和资源，如果是浏览器访问过的资源，浏览器缓存上有对应的，会与服务器最后修改时间对比，一致则返回304;
7. 如果 html 没缓存，则浏览器开始下载 html 文档(响应报头，状态码200)，同时使用缓存;
8. html 一边下载一边解析 html，根据标签建立文档树 DOM
9. 其中根据标记下载所需css、js、图片文件，其中 css 是异步下载，同步执行(By default CSS is treated as a render blocking resource, html 也是)并会阻塞式的建立 CSSOM, 然后这俩一起会 render 成完整的 render 树（最后我们看到的样子），然后再因为假如把 css 放到底部,可能页面会出现白屏(阻塞 render)，或者布局混乱样式很丑直到CSS加载完成闪跳(rerender)的感觉。所以写到顶部确保用户至少能早一点看到界面。
10. js 在现代浏览器里面是异步下载，同步执行的，最好放到底部。因为对于在 js 后面的内容（html），html 的逐步呈现会被阻塞。
11. 当 js 运行完成，页面加载完成。

### WEB应用从服务器主动推送Data到客户端有那些方式？

- html5提供的Websocket
- ajax 长时间连接
- ajax 长轮询

### 介绍一下 cookie、localStorage、sessionStorage

#### Cookie

Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。

一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效。**每次** 都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题（每一次的 http 请求的大小都会加上 cookie 的大小）,所以Cookie 当然是能精简就精简

#### localStorage

localStorage 是 HTML5 标准中新加入的技术, 用于本地存储, 仅在客户端（即浏览器）中保存，不参与和服务器的通信。

曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了。HTML5游戏也非常适合使用。

#### sessionStorage

sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当 **页面关闭** 后，sessionStorage 中的数据就会被清空。

如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。

**OSI，TCP/IP，五层协议的体系结构，以及各层协议** 

  **OSI分层 （7层）**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 

  **TCP/IP分层（4层）**：网络接口层、 网际层、运输层、 应用层。 

  **五层协议     （5层）**：物理层、数据链路层、网络层、运输层、 应用层。 

  **每一层的协议如下:**

  物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关） 
  数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） 
  网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 
  传输层：TCP、UDP、SPX 
  会话层：NFS、SQL、NETBIOS、RPC 
  表示层：JPEG、MPEG、ASII 
  应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 

​    **物理层：**通过媒介传输比特,确定机械及电气规范（比特Bit）  

​    **数据链路层**：将比特组装成帧和点到点的传递（帧Frame）  

​    **网络层**：负责数据包从源到宿的传递和网际互连（包PackeT）  

​    **传输层**：提供端到端的可靠报文传递和错误恢复（段Segment）  

​    **会话层**：建立、管理和终止会话（会话协议数据单元SPDU）  

​    **表示层**：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）  

​    **应用层**：允许访问OSI环境的手段（应用协议数据单元APDU）  

​    **IP地址的分类**

​     A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；  
​     B类地址：以10开头，    第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；  
​     C类地址：以110开头，  第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；  


​    


​    **IP地址与子网掩码相与得到主机号**


​    **ARP是地址解析协议，简单语言解释一下工作原理。**


​    1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。


​    2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：**源主机IP地址，源主机MAC地址，目的主机的IP地址**。


​    3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。


​    4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。


​    **各种协议**

​    **HTTP协议 **超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。  

![http消息结构](http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=5984001)

![](http://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=5984001)

##### 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。

第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）

##### 第二部分：消息报头，用来说明客户端要使用的一些附加信息

第二行和第三行为消息报头，
Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8

##### 第三部分：空行，消息报头后面的空行是必须的

##### 第四部分：响应正文，服务器返回给客户端的文本信息。 

空行后面的html部分为响应正文。

​    **TCP三次握手和四次挥手的全过程**

  **三次握手：**

  第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 

  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 

  第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 

  握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 

  **四次握手**

  与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 
  第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。 
  第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

  第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

  第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

![](http://images0.cnblogs.com/blog2015/621032/201508/092017231747399.jpg)

**在浏览器中输入www.baidu.com后执行的全部过程**


  1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 

  2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 

  3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 

  4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

## 其他

1. **JSON官方的转换方式**：http://www.json.org/提供了一个json.js 这样ie8(兼容模式),ie7和ie6就可以支持JSON对象以及其stringify()和parse()方法； 
2. stringObject.substring(start,stop)会把负数变成0，stringObject.substr(start,length)的start位可以为负数（从后往前），length位为负会取到空字符串。
3. 判断CSS加载完毕：Chrome / Safari:    linkNode.sheet 在 css 文件下载完成并解析好后才有值，之前为 undefined    linkNode.sheet.cssRules 同域时返回 CSSRuleList, 跨域时返回 null
4. 合并数组：Array.prototype.push.apply(a, b); 合并a，b数组or a.concat(b)
5. 中序遍历：左根右 后序遍历：左右根
6. 函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。
7. 移动端适配：字体->REM  drawer百分比 header 定高度px