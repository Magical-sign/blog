# 数据结构和算法

## 排序算法

![算法](http://images2015.cnblogs.com/blog/739525/201605/739525-20160503202729044-614991035.jpg)

排序算法稳定性的简单形式化定义为：**如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。**通俗地讲就是保证排序前后两个相等的数的相对顺序不变。

#### 冒泡排序

#### 简单选择排序

#### 直接插入排序

#### 快速排序

# 计算机网络

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）[](https://simplyy.space/article/56d8377063fac2a8175b41f4#一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）)

> 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

简洁版

- 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图像等）；
- 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
- 载入解析到的资源文件，渲染页面，完成。

图来自耗子的酷壳 [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html) ![img](http://7xkpdt.com1.z0.glb.clouddn.com/7af8074fc21748eca9e93c261298860f.png)

详细版

1. 浏览器会开启一个新的线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
2. 通过 DNS 解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
3. 进行 HTTP 协议会话，客户端发送报头(请求报头);
4. 进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
5. 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
6. 处理结束回馈报头，和资源，如果是浏览器访问过的资源，浏览器缓存上有对应的，会与服务器最后修改时间对比，一致则返回304;
7. 如果 html 没缓存，则浏览器开始下载 html 文档(响应报头，状态码200)，同时使用缓存;
8. html 一边下载一边解析 html，根据标签建立文档树 DOM
9. 其中根据标记下载所需css、js、图片文件，其中 css 是异步下载，同步执行(By default CSS is treated as a render blocking resource, html 也是)并会阻塞式的建立 CSSOM, 然后这俩一起会 render 成完整的 render 树（最后我们看到的样子），然后再因为假如把 css 放到底部,可能页面会出现白屏(阻塞 render)，或者布局混乱样式很丑直到CSS加载完成闪跳(rerender)的感觉。所以写到顶部确保用户至少能早一点看到界面。
10. js 在现代浏览器里面是异步下载，同步执行的，最好放到底部。因为对于在 js 后面的内容（html），html 的逐步呈现会被阻塞。
11. 当 js 运行完成，页面加载完成。

### http状态码有那些？分别代表是什么意思？[](https://simplyy.space/article/56d8377063fac2a8175b41f4#http状态码有那些？分别代表是什么意思？)

- 1**(信息类)：表示接收到请求并且继续处理
  - 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
- 2**(响应成功)：表示动作被成功接收、理解和接受
  - 200 OK 正常返回信息
  - 201 Created 请求成功并且服务器创建了新的资源
  - 202 Accepted 服务器已接受请求，但尚未处理
- 3**(重定向类)：为了完成指定的动作，必须接受进一步处理
  - 301 Moved Permanently 请求的网页已永久移动到新位置。
  - 302 Found 临时性重定向。
  - 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。
  - 304 Not Modified 自从上次请求后，请求的网页未修改过。
- 4**(客户端错误类)：请求包含错误语法或不能正确执行
  - 401 Unauthorized 请求未授权验证。
  - 403 Forbidden 禁止访问。
  - 404 Not Found 找不到如何与 URI 相匹配的资源。
- 5**(服务端错误类)：服务器不能正确执行一个正确的请求
  - 500 Internal Server Error 服务器遇到错误，最常见的服务器端错误。
  - 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

### WEB应用从服务器主动推送Data到客户端有那些方式？[](https://simplyy.space/article/56d8377063fac2a8175b41f4#WEB应用从服务器主动推送Data到客户端有那些方式？)

- html5提供的Websocket
- ajax 长时间连接
- ajax 长轮询

### 介绍一下 cookie、localStorage、sessionStorage[](https://simplyy.space/article/56d8377063fac2a8175b41f4#介绍一下 cookie、localStorage、sessionStorage)

#### Cookie[](https://simplyy.space/article/56d8377063fac2a8175b41f4#Cookie)

Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。

一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效。**每次** 都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题（每一次的 http 请求的大小都会加上 cookie 的大小）,所以Cookie 当然是能精简就精简

#### localStorage[](https://simplyy.space/article/56d8377063fac2a8175b41f4#localStorage)

localStorage 是 HTML5 标准中新加入的技术, 用于本地存储, 仅在客户端（即浏览器）中保存，不参与和服务器的通信。

曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了。HTML5游戏也非常适合使用。

#### sessionStorage[](https://simplyy.space/article/56d8377063fac2a8175b41f4#sessionStorage)

sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当 **页面关闭** 后，sessionStorage 中的数据就会被清空。

如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。

![优化](http://images.cnitblog.com/blog/275014/201308/17194803-cbaa54f624bb4d529ddddaba7f7cf3df.png)

### 跨域解决办法

#### CORS

服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问

#### JSONP

利用script标签的特性，将数据使用json格式用一个函数包裹起来，然后在进行访问的页面中定义一个相同函数名的函数，因为 script 标签src引用的js脚本到达浏览器时会执行，而我们有定义了一个同名的函数，所以json格式的数据，就在callback中做参数传递给了我们定义的同名函数了。callback！

**安全问题：**callback参数注入、资源访问授权设置

#### window.postMessage

HTML5的新特性 依赖iframe

#### window.name

依赖iframe

#### document.domain

修改域名跨域

## 常见web安全及防护原理[](https://simplyy.space/article/56da6d841795204c56032e21#常见web安全及防护原理)

### sql注入[](https://simplyy.space/article/56da6d841795204c56032e21#sql注入)

就是通过把SQL命令插入到Web表单中递交，或插入到输入包含查询字符串（query string）的 url，最终达到欺骗服务器执行恶意的SQL命令。

#### 避免方式[](https://simplyy.space/article/56da6d841795204c56032e21#避免方式)

前端需

1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2. 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

### XSS[](https://simplyy.space/article/56da6d841795204c56032e21#XSS)

Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者插入 js 代码，然后运行，或者甚至替换你的 script 标签（联通手机流量这么干过劫持，然后你的代码就运行不了啦。。被替换成他的了，然后攻击者想干啥就干啥，只要你能干的，他都可以干）。

#### 防范[](https://simplyy.space/article/56da6d841795204c56032e21#防范)

首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤

其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。

encode html tag

```
& -> &amp;
< -> &lt;
> -> &gt;
```

```
function safeTagsReplace(str) {
    return str.replace(/[&<>]/g, replaceTag);
}

function replaceTag(tag) {
    var tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };

    return tagsToReplace[tag] || tag;
}
```

### CSRF[](https://simplyy.space/article/56da6d841795204c56032e21#CSRF)

CSRF（Cross-site request forgery），中文名称：跨站请求伪造

你这可以这么理解CSRF攻击：**攻击者盗用了你的身份，以你的名义发送恶意请求**。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

要完成一次CSRF攻击，受害者必须依次完成两个步骤：

1. （1）.你正常访问信任站点（[http://www.Bank.com](http://www.bank.com/)），然后登陆信任站点。

   （2）.信任站点通过你的验证，并返回Cookie。

   （3）.这时，在你还没有登出信任站点之前，你再打开了一个浏览器的tab页，并访问了一个恶意站点（[www.BadGuy.com](http://www.badguy.com/)）。

   （4）.恶意站点向请求用户访问[http://www.Bank.com](http://www.bank.com/)的一个资源。

   （5）.浏览器带着之前的Cookie信息，向信任站点[http://www.Bank.com](http://www.bank.com/)发出了一个GET请求。

   （6）.信任站点验证的Cookie信息通过，根据请求返回一个JSON数组（如果不清楚JSON，可以参考《[JSON入门指南](http://www.cnblogs.com/hyddd/archive/2009/06/15/1503914.html)》）。

   （7）.你的浏览器收到来自[http://www.Bank.com](http://www.bank.com/)的响应后，转发响应中的JSON信息给恶意站点。

   （8）至此，恶意站点拿到你关于[http://www.Bank.com](http://www.bank.com/)的信息。

#### CSRF的防御[](https://simplyy.space/article/56da6d841795204c56032e21#CSRF的防御)

服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

原理就是，要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击

1. 使用验证码
2. 添加 token 并验证 

![数据库对比](http://img.bbs.csdn.net/upload/201409/15/1410763091_874088.png)

### XML与JSON

XML是可扩展标记语言 

(1).XML的优缺点
<2>.XML的缺点
　　A.XML文件庞大，文件格式复杂，传输占带宽；
　　B.服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；
　　C.客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；
　　D.服务器端和客户端解析XML花费较多的资源和时间。

(2).JSON的优缺点
<1>.JSON的优点：
　　A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；
　　B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；
　　E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。

### 问：说一下你了解的http报头有哪些？

答：cache-control；if-Match，检测Etag的；if-modified-since（我当时这个只是答到了它的作用，没答出名字）。然后说不知道了，（可突然想起了跨域的那个），就说有一个是跨域的。

### 内存泄漏

**1.IE7/8 DOM对象或者ActiveX对象循环引用导致内存泄漏**

由于引用计数清除机制

**2.基础的DOM泄漏**

当原有的DOM被移除时，子结点引用没有被移除则无法回收

**3.timer定时器泄漏**

## Gulp和webpack

Gulp侧重于前端开发的 **整个过程** 的控制管理（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。

Webpack有人也称之为 **模块打包机** ，由此也可以看出Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的。

另外我们知道Gulp是对整个过程进行控制，所以在其配置文件（gulpfile.js）中配置的每一个task对项目中 **该task配置路径下所有的资源** 都可以管理。

Gulp可以对css文件以及js文件进行合并压缩处理，而Webpack可以实现对css文件，js文件，html文件等进行合并压缩和图片的压缩，还可以对js文件进行编译（如es6–>es5，react jsx）等等，这些都是通过Webpack的 **loader** 实现的，当然这些也可以加入到Gulp中，毕竟Gulp把Webpack当做一个模块，通过 **gulp-webpack** 都引入了。

## 哈希表

哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。

使用哈希查找有两个步骤:

1. 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突
2. 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

## 懒加载的原理

- 原理：先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。
- 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。

**TCP的可靠性如何保证：**

在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。

**OSI，TCP/IP，五层协议的体系结构，以及各层协议** 

  **OSI分层 （7层）**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 

  **TCP/IP分层（4层）**：网络接口层、 网际层、运输层、 应用层。 

  **五层协议     （5层）**：物理层、数据链路层、网络层、运输层、 应用层。 

  **每一层的协议如下:**

  物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关） 
  数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） 
  网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 
  传输层：TCP、UDP、SPX 
  会话层：NFS、SQL、NETBIOS、RPC 
  表示层：JPEG、MPEG、ASII 
  应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 

​    **物理层：**通过媒介传输比特,确定机械及电气规范（比特Bit）  

​    **数据链路层**：将比特组装成帧和点到点的传递（帧Frame）  

​    **网络层**：负责数据包从源到宿的传递和网际互连（包PackeT）  

​    **传输层**：提供端到端的可靠报文传递和错误恢复（段Segment）  

​    **会话层**：建立、管理和终止会话（会话协议数据单元SPDU）  

​    **表示层**：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）  

​    **应用层**：允许访问OSI环境的手段（应用协议数据单元APDU）  

​    **IP地址的分类**

​     A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；  
​     B类地址：以10开头，    第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；  
​     C类地址：以110开头，  第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；  


​    


​    **IP地址与子网掩码相与得到主机号**


​    **ARP是地址解析协议，简单语言解释一下工作原理。**


​    1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。


​    2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：**源主机IP地址，源主机MAC地址，目的主机的IP地址**。


​    3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。


​    4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。


​    **各种协议**

​    **HTTP协议 **超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。  

![http消息结构](http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=5984001)

![](http://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=5984001)

##### 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。

第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）

##### 第二部分：消息报头，用来说明客户端要使用的一些附加信息

第二行和第三行为消息报头，
Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8

##### 第三部分：空行，消息报头后面的空行是必须的

##### 第四部分：响应正文，服务器返回给客户端的文本信息。 

空行后面的html部分为响应正文。

​    **TCP三次握手和四次挥手的全过程**

  **三次握手：**

  第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 

  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 

  第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 

  握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 

  **四次握手**

  与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 
  第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。 
  第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

  第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

  第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

![](http://images0.cnblogs.com/blog2015/621032/201508/092017231747399.jpg)

**在浏览器中输入www.baidu.com后执行的全部过程**


  1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 

  2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 

  3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 

  4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

**DNS域名系统，简单描述其工作原理。**

  当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。

# HTTP2

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如`Cookie`和`User Agent`，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用`gzip`或`compress`压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

# HTTP请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

```
GET     请求指定的页面信息，并返回实体主体。
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
DELETE      请求服务器删除指定的页面。
CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     允许客户端查看服务器的性能。
TRACE     回显服务器收到的请求，主要用于测试或诊断。
```

# HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

以下是 HTTP 请求/响应的步骤：

###### 1、客户端连接到Web服务器

一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.oakcms.cn。](http://www.oakcms.cn./)

###### 2、发送HTTP请求

通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

###### 3、服务器接受请求并返回HTTP响应

Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

###### 4、释放连接[TCP连接](http://www.jianshu.com/p/ef892323e68f)

若connection 模式为close，则服务器主动关闭[TCP连接](http://www.jianshu.com/p/ef892323e68f)，客户端被动关闭连接，释放[TCP连接](http://www.jianshu.com/p/ef892323e68f);若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

###### 5、客户端浏览器解析HTML内容

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;

2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立[TCP连接](http://www.jianshu.com/p/ef892323e68f);

 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 [TCP 三次握手](http://www.jianshu.com/p/ef892323e68f)的第三个报文的数据发送给服务器;

4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;

5、释放 [TCP连接](http://www.jianshu.com/p/ef892323e68f);

6、浏览器将该 html 文本并显示内容; 　　

## GET VS POST

1. 1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.
   2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
   3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.

Node.js优点：
1、采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。
2、Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。3、Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。

## decorator

1. 动态扩展
2. 不用（继承）产生新的子类（class）

## 其他

1. **JSON官方的转换方式**：http://www.json.org/提供了一个json.js 这样ie8(兼容模式),ie7和ie6就可以支持JSON对象以及其stringify()和parse()方法； 
2. stringObject.substring(start,stop)会把负数变成0，stringObject.substr(start,length)的start位可以为负数（从后往前），length位为负会取到空字符串。
3. 判断CSS加载完毕：Chrome / Safari:    linkNode.sheet 在 css 文件下载完成并解析好后才有值，之前为 undefined    linkNode.sheet.cssRules 同域时返回 CSSRuleList, 跨域时返回 null
4. 合并数组：Array.prototype.push.apply(a, b); 合并a，b数组or a.concat(b)
5. 中序遍历：左根右 后序遍历：左右根
6. 函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。
7. 移动端适配：字体->REM  drawer百分比 header 定高度px