# 数据结构和算法

## 排序算法

![算法](http://images2015.cnblogs.com/blog/739525/201605/739525-20160503202729044-614991035.jpg)

排序算法稳定性的简单形式化定义为：**如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。**通俗地讲就是保证排序前后两个相等的数的相对顺序不变。

#### 冒泡排序

#### 简单选择排序

#### 直接插入排序

#### 快速排序

### 跨域解决办法

#### CORS

服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问

#### JSONP

利用script标签的特性，将数据使用json格式用一个函数包裹起来，然后在进行访问的页面中定义一个相同函数名的函数，因为 script 标签src引用的js脚本到达浏览器时会执行，而我们有定义了一个同名的函数，所以json格式的数据，就在callback中做参数传递给了我们定义的同名函数了。callback！

**安全问题：**callback参数注入、资源访问授权设置

#### window.postMessage

HTML5的新特性 依赖iframe

#### window.name

依赖iframe

#### document.domain

修改域名跨域

## 常见web安全及防护原理[](https://simplyy.space/article/56da6d841795204c56032e21#常见web安全及防护原理)

### sql注入[](https://simplyy.space/article/56da6d841795204c56032e21#sql注入)

就是通过把SQL命令插入到Web表单中递交，或插入到输入包含查询字符串（query string）的 url，最终达到欺骗服务器执行恶意的SQL命令。

#### 避免方式[](https://simplyy.space/article/56da6d841795204c56032e21#避免方式)

前端需

1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2. 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

### XSS[](https://simplyy.space/article/56da6d841795204c56032e21#XSS)

Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者插入 js 代码，然后运行，或者甚至替换你的 script 标签（联通手机流量这么干过劫持，然后你的代码就运行不了啦。。被替换成他的了，然后攻击者想干啥就干啥，只要你能干的，他都可以干）。

#### 防范[](https://simplyy.space/article/56da6d841795204c56032e21#防范)

首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤

其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。

encode html tag

```
& -> &amp;
< -> &lt;
> -> &gt;
```

```
function safeTagsReplace(str) {
    return str.replace(/[&<>]/g, replaceTag);
}

function replaceTag(tag) {
    var tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };

    return tagsToReplace[tag] || tag;
}
```

### CSRF[](https://simplyy.space/article/56da6d841795204c56032e21#CSRF)

CSRF（Cross-site request forgery），中文名称：跨站请求伪造

你这可以这么理解CSRF攻击：**攻击者盗用了你的身份，以你的名义发送恶意请求**。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

要完成一次CSRF攻击，受害者必须依次完成两个步骤：

1. （1）.你正常访问信任站点（[http://www.Bank.com](http://www.bank.com/)），然后登陆信任站点。

   （2）.信任站点通过你的验证，并返回Cookie。

   （3）.这时，在你还没有登出信任站点之前，你再打开了一个浏览器的tab页，并访问了一个恶意站点（[www.BadGuy.com](http://www.badguy.com/)）。

   （4）.恶意站点向请求用户访问[http://www.Bank.com](http://www.bank.com/)的一个资源。

   （5）.浏览器带着之前的Cookie信息，向信任站点[http://www.Bank.com](http://www.bank.com/)发出了一个GET请求。

   （6）.信任站点验证的Cookie信息通过，根据请求返回一个JSON数组（如果不清楚JSON，可以参考《[JSON入门指南](http://www.cnblogs.com/hyddd/archive/2009/06/15/1503914.html)》）。

   （7）.你的浏览器收到来自[http://www.Bank.com](http://www.bank.com/)的响应后，转发响应中的JSON信息给恶意站点。

   （8）至此，恶意站点拿到你关于[http://www.Bank.com](http://www.bank.com/)的信息。

#### CSRF的防御[](https://simplyy.space/article/56da6d841795204c56032e21#CSRF的防御)

服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

原理就是，要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击

1. 使用验证码
2. 添加 token 并验证 

### XML与JSON

XML是可扩展标记语言 

(1).XML的优缺点
<2>.XML的缺点
　　A.XML文件庞大，文件格式复杂，传输占带宽；
　　B.服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；
　　C.客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；
　　D.服务器端和客户端解析XML花费较多的资源和时间。

(2).JSON的优缺点
<1>.JSON的优点：
　　A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；
　　B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；
　　E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。

### 内存泄漏

**1.IE7/8 DOM对象或者ActiveX对象循环引用导致内存泄漏**

由于引用计数清除机制

**2.基础的DOM泄漏**

当原有的DOM被移除时，子结点引用没有被移除则无法回收

**3.timer定时器泄漏**

## Gulp和webpack

Gulp侧重于前端开发的 **整个过程** 的控制管理（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。

Webpack有人也称之为 **模块打包机** ，由此也可以看出Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的。

另外我们知道Gulp是对整个过程进行控制，所以在其配置文件（gulpfile.js）中配置的每一个task对项目中 **该task配置路径下所有的资源** 都可以管理。

Gulp可以对css文件以及js文件进行合并压缩处理，而Webpack可以实现对css文件，js文件，html文件等进行合并压缩和图片的压缩，还可以对js文件进行编译（如es6–>es5，react jsx）等等，这些都是通过Webpack的 **loader** 实现的，当然这些也可以加入到Gulp中，毕竟Gulp把Webpack当做一个模块，通过 **gulp-webpack** 都引入了。

## 哈希表

哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。

使用哈希查找有两个步骤:

1. 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突
2. 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

## 懒加载的原理

- 原理：先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。
- 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。

